---
title: Деревья поиска. АВЛ и рандомизированные деревья поиска
description: Ты не заметишь этот миг, лишь только завтра поутру
date: 2018-12-05T14:00:00Z
draft: true
categories:
- algorithm
tags:
- data-structure
- complexity
toc: true
katex: true
mermaid: true
---

Большие объёмы данных требуют особых подходов к задаче поиска. Если для нахождения элемента среди пары сотен элементов за линейное время достаточно хорошо, то когда речь идёт о тысячах и миллионах элементов, линейное время оказывается неоправданно большим. Можно воспользоваться известным нам бинарным поиском или даже его адаптацией [галопированием]({{<relref "../10/merge-sort.md">}}). Но и это оказывается неэффективно при работе с данными, не влезающими в оперативную память. Действительно, пусть у нас есть файл размера 1 Гб с отсортированными данными. Пусть буфер чтения составляет 1 Кб. Тогда для бинарного поиска потребуется \\(\log\frac{2^{30}}{2^{10}} = \log 2^{20} = 20\\) чтений с диска. Это очень много. Давайте рассмотрим структуры, позволяющие искать быстрее и использовать компактные индексы по данным.

## Деревья поиска

Для начала ограничим ветвистость рассматриваемых деревьев до \\(2\\). Деревья с большей ветвистостью обычно называются B-деревьями и будут рассматриваться в другой статье.

Двоичное дерево будем называть _двоичным деревом поиска_, если для каждой вершины дерева \\(u\\) определено отображение в линейно упорядоченное множество \\(k(u)\\), при этом для любой вершины из дерева её левого сына образ этого отображения меньше или равен образа вершины \\(u\\), а для правого дерева выполнено аналогичное неравенство со знаком больше или равно. То есть:
{{<equation>}}
\forall u \in T \implies
    (\forall v \in T_{u_\ell} \implies v \leqslant u) \land
    (\forall v \in T_{u_r} \implies v \geqslant u)
{{</equation>}}
