<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Где-то на дальнем сервере</title>
    <link>https://vporoshok.me/</link>
    <description>Recent content on Где-то на дальнем сервере</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <lastBuildDate>Sun, 17 Mar 2019 17:35:25 +0000</lastBuildDate>
    
	<atom:link href="https://vporoshok.me/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>O3: разговоры тет-а-тет</title>
      <link>https://vporoshok.me/post/2019/02/one-on-one/</link>
      <pubDate>Sun, 17 Mar 2019 17:35:25 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/02/one-on-one/</guid>
      <description>Разговоры один на один между куратором и сотрудниками часто в англоязычных источниках называются one-on-one или просто O3. Для многих компаний это обычная практика, а среди европейских it-компаний уже трудно найти ту, где такие сессии не проводятся. Так давайте разбираться что это, для чего и как.
Что же такое O3? O3 это приватная встреча между куратором и сотрудником. Такие встречи обычно проводятся раз в одну или две недели. На этих встречах обсуждаются текущее состояние сотрудника, его переживания связанные с работой, вопросы, которые не столь критичны, что требуют незамедлительной реакции, но важны в перспективе.</description>
    </item>
    
    <item>
      <title>Задачи RMQ и LCA</title>
      <link>https://vporoshok.me/slides/2019/03/rmq__lca/</link>
      <pubDate>Sat, 09 Mar 2019 04:07:12 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2019/03/rmq__lca/</guid>
      <description>.w-25 { width: 25%; margin-left: auto; margin-right: auto; }  \[ \gdef\rmq{\mathop{\mathrm{rmq}}} \gdef\lca{\mathop{\mathrm{lca}}} \gdef\new{\mathop{\mathrm{new}}} \]  Задачи RMQ и LCA   План  задача и применение RMQ -&amp;gt; LCA offline LCA online RMQ ±1 RMQ LCA -&amp;gt; ±1 RMQ    Задача и применение   Задача и применение RMQ (range minimum query) Выбор наименьшего элемента в отрезке индексов.
Дано: \(A = \{a_k \colon k &amp;lt; n \}\).</description>
    </item>
    
    <item>
      <title>Семейство непересекающихся множеств</title>
      <link>https://vporoshok.me/slides/2019/03/dsu/</link>
      <pubDate>Fri, 08 Mar 2019 14:57:14 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2019/03/dsu/</guid>
      <description>DSU   Семейство непересекающихся множеств   План  задача и применение ранговая эвристика сжатие путей статистики динамический направленный лес вариант реализации    Задача и применение   Задача и применение Дано множество \(E = \{x_i\colon i &amp;lt; n\}\) &amp;mdash; Универсум.
В каждый момент времени существует разбиение
\[ \mathbb X = \{X_j \colon j такое, что
\[ \cup \mathbb X = E, \quad\text{и}\quad X_j \cap X_l = \varnothing \quad(i \neq j) \]    Задача и применение На семействе \(\mathbb X\) определим 2 операции:</description>
    </item>
    
    <item>
      <title>Хеш-таблицы</title>
      <link>https://vporoshok.me/slides/2019/02/hashing/</link>
      <pubDate>Fri, 01 Mar 2019 16:43:34 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2019/02/hashing/</guid>
      <description>.red { color: red; }  Хеш-таблицы   План  задача и применение неконстантные решения хеширование коллизии анализ сложности с допущениями без допущений    Задача и применение   Задача и применение Есть множество пар \((k, v)\) &amp;mdash; ключ-значение. Необходимо построить структуру хранения этих пар так, чтобы на ней были определены операции:
 set(k, v) get(k) delete(k)    Неконстантные решения   Неконстантные решения          Структура new set get del   Массив \(O(n)\) \(O(1)\) \(O(n)\) \(O(n)\) Отсортированный массив \(O(n\log n)\) \(O(\log n)^\star\) \(O(\log n)^\star\) \(O(\log n)^\star\) Дерево поиска \(O(n)\) \(O(\log n)\) \(O(\log n)\) \(O(\log n)\) Хочется \(O(n)\) \(O(1)\) \(O(1)\) \(O(1)\)    Хеширование   Хеширование Выделим массив для хранения пар размера \(N\), при этом допустимое множество ключей \(K\) такое, что \(|K| \gg N\).</description>
    </item>
    
    <item>
      <title>Не пишите CSS</title>
      <link>https://vporoshok.me/slides/2019/02/utility-classes/</link>
      <pubDate>Sun, 24 Feb 2019 10:31:26 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2019/02/utility-classes/</guid>
      <description>.title h2 { font-weight: bold; text-align: right; } .shadow figure:after { content: &#39;&#39;; position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; z-index: -1; background-color: rgba(0, 0, 0, 0.3); } #stop-digging h2 { position: absolute; margin-top: 150px; } .cards { display: flex; width: 100%; justify-content: space-between; align-items: stretch; font-size: 0.7rem; font-weight: 300; line-height: 1.3; } .card { width: 23%; border: 1px solid slateblue; } .</description>
    </item>
    
    <item>
      <title>Декораторы в Go</title>
      <link>https://vporoshok.me/post/2019/01/decorators/</link>
      <pubDate>Thu, 24 Jan 2019 16:25:25 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/decorators/</guid>
      <description>Довольно большая часть моей работы заключается в написании библиотечного кода. Кода, который будет многократно использоваться как другими программистами, так и мной самим. Поэтому одним из важных критериев становится удобство интерфейсов. Некоторые применяемые мной практики рассмотрены в этой статье.
Перехватчики Концепция middleware появилась, конечно, задолго до go. Будем называть их перехватчиками, что не по фен-шую, но лучше, чем «слой промежуточного программного обеспечения». Однако, именно в go эта концепция достигла своего апогея.</description>
    </item>
    
    <item>
      <title>Рефлексия в Go</title>
      <link>https://vporoshok.me/post/2019/01/reflection/</link>
      <pubDate>Sun, 20 Jan 2019 05:30:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/reflection/</guid>
      <description>Зачем ты озабочен
В этот хороший миг одним упорным выяснением,
Как тебя люди другие видят. Тратишь воображение
На домыслы пустые о домыслах касательно своей персоны.
У тебя рефлексия, опасная стадия. Есть есть есть «Рефлексия»    Что же такое рефлексия и для чего она нужна? Рефлексия это механизм, с помощью которого программа может проверять своё состояние, исследовать типы данных и менять свою структуру и поведение во время выполнения. Звучит довольно запутано, но давайте раскладывать по полочкам.</description>
    </item>
    
    <item>
      <title>Хакатон. Как не перестать улыбаться за 24 часа</title>
      <link>https://vporoshok.me/post/2019/01/hackathon/</link>
      <pubDate>Thu, 03 Jan 2019 08:08:58 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2019/01/hackathon/</guid>
      <description>Что же такое хакатон? Термин «хакатон» является словослиянием двух слов: хак (hack) и марафон (marathon).
Впервые это слово появляется в 1999 году независимо друг от друга на двух событиях: встреча разработчиков OpenBSD и конференция JavaOne. В первом случае 10 человек в течении дня разрабатывали криптографические программы, которые бы обходили ограничения США на экспорт криптографических систем, а во втором случае всем желающим было предложено в течении конференции разработать программу на Java для Palm V с использованием ИК-порта.</description>
    </item>
    
    <item>
      <title>Хакатон. Как не перестать улыбаться за 24 часа</title>
      <link>https://vporoshok.me/slides/2018/12/hackathon/</link>
      <pubDate>Tue, 25 Dec 2018 12:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2018/12/hackathon/</guid>
      <description>.places { position: relative; } .w-30 { width: 33.3%; height: 50%; object-fit: cover; } .marathon h2 { position: absolute; top: 60px; } .versus { position: relative; } .versus h2 { font-size: 72px; font-weight: bold !important; } .versus sup, .versus sub { position: absolute; display: inline-block; font-size: 1em; line-height: 1; } .versus sup { top: 200px; left: 60px; } .versus sub { bottom: 200px; right: 60px; } .versus span { display: none; } .</description>
    </item>
    
    <item>
      <title>Деревья поиска. АВЛ-деревья</title>
      <link>https://vporoshok.me/post/2018/12/search-tree/</link>
      <pubDate>Thu, 20 Dec 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/12/search-tree/</guid>
      <description>Большие объёмы данных требуют особых подходов к задаче поиска. Если для нахождения элемента среди пары сотен элементов за линейное время достаточно хорошо, то когда речь идёт о тысячах и миллионах элементов, линейное время оказывается неоправданно большим. Можно воспользоваться известным нам бинарным поиском или даже его адаптацией галопированием. Но и это оказывается неэффективно при работе с данными, не влезающими в оперативную память. Действительно, пусть у нас есть файл размера 1 Гб с отсортированными данными.</description>
    </item>
    
    <item>
      <title>Как и для чего изучать алгоритмы</title>
      <link>https://vporoshok.me/post/2018/11/introduction/</link>
      <pubDate>Thu, 29 Nov 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/11/introduction/</guid>
      <description>Иногда студенты, коллеги и знакомые задают мне вопросы о том
 почему нужно изучать алгоритмы? какой смысл в понимании оценок алгоритмов? для чего так много времени уделять алгоритмам, которые реализованы в стандартных библиотеках? пригождаются ли все эти знания в повседневной работе программиста? стоит ли разбираться javascript-разработчику с тем во что компилируется код на C и ассемблером вообще?  Отрывочно я старался отвечать на эти вопросы и раньше, однако теперь у меня сложилось более или менее целостное представление обо всех этих и многих других вопросах, кое я и попытаюсь изложить в этой статье.</description>
    </item>
    
    <item>
      <title>Кучи с эффективным слиянием</title>
      <link>https://vporoshok.me/post/2018/11/meldable-heaps/</link>
      <pubDate>Thu, 15 Nov 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/11/meldable-heaps/</guid>
      <description>В статье про двоичную кучу было рассказано про устройство такой структуры данных как куча, а также приведён пример реализации в виде двоичной кучи. Такая реализация обладает двумя бесспорными преимуществами: простотой и компактностью хранения. Однако одна операция, часто требуемая от кучи в ней имеет слишком высокую сложность, эта операция слияние (meld). По сути лучшим способом слияния двоичных куч является построение новой кучи на объединённом массиве элементов. Сложность такой операции будет \(O(n + m)\) или, если одна из сливаемых куч сильно меньше другой, то можно поэлементно добавить первую ко второй, получив сложность \(O(n \log m)\).</description>
    </item>
    
    <item>
      <title>Кучи с эффективным слиянием</title>
      <link>https://vporoshok.me/slides/2018/11/meldable-heaps/</link>
      <pubDate>Thu, 15 Nov 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2018/11/meldable-heaps/</guid>
      <description>.w-75 { width: 75%; margin-left: auto; margin-right: auto; } .w-50 { width: 50%; margin-left: auto; margin-right: auto; } .w-25 { width: 25%; margin-left: auto; margin-right: auto; }  Кучи с эффективным слиянием   План  задача и применение биномиальные кучи  хранение и адресация слияние извлечение минимума  левацкие кучи     Задача и применение   Задача и применение Операция слияния куч находит применение в таких алгоритмах, как многопутевые слияния, поиск кратчайшего пути в графе и других.</description>
    </item>
    
    <item>
      <title>Слияние больших массивов данных</title>
      <link>https://vporoshok.me/post/2018/11/merge-sort-2/</link>
      <pubDate>Thu, 08 Nov 2018 14:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/11/merge-sort-2/</guid>
      <description>Итак, изучив кучи в первом приближении, можно вернуться к сортировке слиянием и рассмотреть те случаи, где другая сортировка работать не будет в принципе. Речь на этот раз пойдёт о таких объёмах данных, которые не влезают в оперативную (внутреннюю) память.
Об уровнях памяти Часто, говоря о памяти компьютера, предлагают рассматривать лишь оперативную (RAM) и дисковую (HDD / SSD). На самом деле уровней памяти в современном компьютере значительно больше. Если упростить некоторые вещи, то можно рассматривать следующую иерархию:</description>
    </item>
    
    <item>
      <title>Простая двоичная куча</title>
      <link>https://vporoshok.me/post/2018/11/simple-heap/</link>
      <pubDate>Fri, 02 Nov 2018 15:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/11/simple-heap/</guid>
      <description>Часто возникает необходимость «сортировать» динамический набор данных. Самым ярким примером такой задачи является очередь с приоритетом. По сути задача сводится к последовательному выбору минимумов из множества, при этом допускающего добавление к множеству новых элементов. Конечно, эту задачу можно решить с помощью сортировки начального множества, а новые элементы можно включать с помощью бинарной вставки. Однако, есть структуры данных, позволяющие реализовать необходимые операции за меньшую стоимость. Такая структура называется куча (heap).</description>
    </item>
    
    <item>
      <title>Простая двоичная куча</title>
      <link>https://vporoshok.me/slides/2018/11/simple-heap/</link>
      <pubDate>Fri, 02 Nov 2018 15:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/slides/2018/11/simple-heap/</guid>
      <description>.red { color: red; }  Двоичная куча   План  задача и применение куча: определение и базовые операции двоичная куча: определение и индексация реализация базовых операций другие операции и итераторы эффективное построение кучи пирамидальная сортировка    Задача и применение   Задача  Очередь с приоритетом вектор с координатами из линейно упорядоченного множества, на котором определены две операции:  добавление элемента извлечение минимума     Применение  слияние нескольких массивов выбор пордяковых статистик частичная сортировка данных поиск кратчайшего пути построение минимального остова графа    Решения?</description>
    </item>
    
    <item>
      <title>Сортировка слиянием</title>
      <link>https://vporoshok.me/post/2018/10/merge-sort/</link>
      <pubDate>Sat, 27 Oct 2018 08:53:31 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/10/merge-sort/</guid>
      <description>Сортировка слиянием один из тех редких алгоритмов, которые не устаревают, а напротив год от года развивается, получает новые публикации и исследования. Это действительно чудесный со многих сторон алгоритм, который находит применение в современном мире, а исследования, связанные с ним предлагают решения, применимые далеко за пределами сортировки. Это своего рода жемчужина среди всех алгоритмов сортировки.
Базовый алгоритм Mergesort является двойственным к быстрой сортировке и относится к классу алгоритмов «Разделяй и властвуй».</description>
    </item>
    
    <item>
      <title>Разочарование в ревью кода</title>
      <link>https://vporoshok.me/post/2018/08/code-review/</link>
      <pubDate>Sat, 18 Aug 2018 16:51:41 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/08/code-review/</guid>
      <description>⚠️Внимание!В этой статье я лишь поднимаю проблемы и вопросы, не давая ответы, потому что не знаю их на сегодняшний день. При этом всё, что описано в статье, лишь мой опыт и не претендует на истину в последней инстанции. На протяжении последних нескольких лет я довольно активно пропагандировал ревью кода. Когда я только пришёл в компанию, в том отделе, куда меня взяли, не применялся даже git, а о ревью кода и вовсе не слышали.</description>
    </item>
    
    <item>
      <title>Отдельный блог</title>
      <link>https://vporoshok.me/post/2018/06/goto-standalone-blog/</link>
      <pubDate>Sat, 16 Jun 2018 17:33:45 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/06/goto-standalone-blog/</guid>
      <description>Уже несколько раз я пытался вести собственный блог. Какое-то время вёл ЖЖ, по большей части похожий на дневник. Потом я несколько раз пытался завести технический блог, но хватало меня на пару постов, после чего всё угасало. И вот недавно я всё же решил вести технический блог на регулярной основе (регулярностью, конечно, и не пахнет, но всё же). Несмотря на то, что я уже пробовал различные генераторы статических сайтов, сделал выбор в сторону платформы и завёл https://medium.</description>
    </item>
    
    <item>
      <title>Property-based testing</title>
      <link>https://vporoshok.me/post/2018/06/property-based-testing/</link>
      <pubDate>Tue, 12 Jun 2018 16:09:44 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/06/property-based-testing/</guid>
      <description>Сегодня хотелось бы рассмотреть такой подход к тестированию как property-based тесты, или, по-русски говоря, тесты основанные на свойствах. Раньше, когда я слышал это название, то думал, что это способы тестирования свойств классов, в смысле property. А при учёте того, что я слышал об этом исключительно в подкасте DevZen, где за этими словами следовали слова: haskell, scala и erlang, то не особо вдавался в подробности. Однако, на выпуске про TLA+ эта тема меня всё же зацепила, так что я пошёл гуглить и читать.</description>
    </item>
    
    <item>
      <title>Чистая архитектура на Go</title>
      <link>https://vporoshok.me/post/2018/04/clean-architect/</link>
      <pubDate>Sun, 15 Apr 2018 14:14:40 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/04/clean-architect/</guid>
      <description>О том, что такое чистая архитектура можно почитать в оригинале, а также в переводе. Кроме того на том же хабре есть переводы статей о переложении этого подхода на Go: раз, два и три. Но все это разбивается о реальную жизнь, транзакции, переиспользование кода, протомонолит и прочие проблемы. Но обо всём по порядку.
 ⚠️Внимание!Всё описанное является сугубо моим мнением, основанным на некотором количестве боли, испытываемой в работе, особенно с циклическими импортами.</description>
    </item>
    
    <item>
      <title>Чек-лист разработчика</title>
      <link>https://vporoshok.me/post/2018/04/developer-check-list/</link>
      <pubDate>Sun, 08 Apr 2018 07:49:35 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/04/developer-check-list/</guid>
      <description>Всегда В первую очередь надо не забывать о правилах хорошего тона. Оскорбления не разрешаются никому и никогда. Мат тоже желательно исключить из лексикона. Мы должны работать вместе, а не против друг друга, поэтому иногда надо идти на компромиссы. Ясно и чётко излагай свои мысли, аргументируй и доказывай, и тебя услышат.
TL;DR Git
 сообщение должно точно описано где, что и почему было сделано; обновление завендоренных зависимостей, изменения, не относящиеся напрямую к задаче и правки по ревью всегда оформляются отдельным коммитом;  Отчёты</description>
    </item>
    
    <item>
      <title>Цикл статей про Angular</title>
      <link>https://vporoshok.me/post/2018/04/angular-toc/</link>
      <pubDate>Sun, 08 Apr 2018 07:24:33 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2018/04/angular-toc/</guid>
      <description>Мы начали использовать Angular (в то время Angular 2) на одном из проектов нашей компании примерно в сентябре 2016 года. Тогда он только вышел из беты. За плечами у нас не было опыта использования никакого фреймворка, разве что Backbone, но фреймворком его можно назвать лишь с натяжкой. Проект же требовал довольно развесистого веб-приложения. Мы немного пощупали Ember, посмотрели на React, даже попытались воспользоваться Backbone+Marionette, но в итоге остановились на Angular. Порой он причинял нам боль, порой мы упирались в совершенно необъяснимое поведение.</description>
    </item>
    
    <item>
      <title>Разрешение орграфа</title>
      <link>https://vporoshok.me/post/2017/06/orgraph-resolve/</link>
      <pubDate>Sun, 04 Jun 2017 17:00:30 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2017/06/orgraph-resolve/</guid>
      <description>По работе уже не первый раз сталкиваюсь с задачей разрешения графа, например, получить полный список зависимостей пакета или получить список групп пользователя, где группы могут включать друг друга. (Вообще граф зависимостей куда сложнее текущей темы, потому как дуги имеют маски версий, так что отложим этот вопрос на будущее.)
Итак, давайте сформулируем и ограничим задачу. У нас есть (в общем случае) ориентированный граф. Каждая вершина имеет уникальное имя и связанные с ней данные.</description>
    </item>
    
    <item>
      <title>Ещё раз о безопасности или где хранить токен</title>
      <link>https://vporoshok.me/post/2017/05/token-placement/</link>
      <pubDate>Sun, 28 May 2017 17:33:45 +0000</pubDate>
      
      <guid>https://vporoshok.me/post/2017/05/token-placement/</guid>
      <description>В очередной раз встал вопрос о том где и как хранить токен авторизации. Первое что приходит в голову это cookie. Итак, давайте сделаем простенький сайт со странице авторизации и использованием cookie для определения пользователя, а затем попробуем его поломать. Использовать мы будем CSRF атаку. Об этих атаках написано уже немало статей, небольшой список будет в конце. В данном посте хочется добавить практики в эти объяснения на пальцах. Для удобства используем репозиторий с тегами эволюции проекта https://github.</description>
    </item>
    
    <item>
      <title>Всем привет!</title>
      <link>https://vporoshok.me/page/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vporoshok.me/page/about/</guid>
      <description>Меня зовут Евгений. Я работаю программистом в компании ELMA. Занимаюсь архитектурой инфраструктуры и отдельных сервисов для облачного решения по управлению бизнес-процессами. Преподаю алгоритмы и дискретную математику в УдГУ. Люблю гулять с собакой и читать книги. Увлекаюсь музыкой.
На данном сайте я высказываю свою личную точку зрения. Моё мнение может расходиться с мнением компаний, в которых я работаю.
Отдельно хочу сказать спасибо Суюнбаевой Любови за фавиконку.</description>
    </item>
    
  </channel>
</rss>